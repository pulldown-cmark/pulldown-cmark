fn main() {
    generate_tests_from_spec()
}

// If the "gen-tests" feature is absent,
// this function will be compiled down to nothing
#[cfg(any(not(feature = "gen-tests"), not(feature = "std")))]
fn generate_tests_from_spec() {}

// If the feature is present, generate tests
// from any .txt file present in the specs/ directory
//
// Test cases are present in the files in the
// following format:
//
// ```````````````````````````````` example
// markdown
// .
// expected html output
// ````````````````````````````````
#[cfg(all(feature = "gen-tests", feature = "std"))]
fn generate_tests_from_spec() {
    use std::fs::{self, File};
    use std::io::{Read, Write};
    use std::path::PathBuf;

    // This is a hardcoded path to the CommonMark spec because it is not situated in
    // the specs/ directory. It's in an array to easily chain it to the other iterator
    // and make it easy to eventually add other hardcoded paths in the future if needed
    let hardcoded = [
        "./third_party/CommonMark/spec.txt",
        "./third_party/CommonMark/smart_punct.txt",
        "./third_party/GitHub/gfm_table.txt",
        "./third_party/GitHub/gfm_strikethrough.txt",
        "./third_party/GitHub/gfm_tasklist.txt",
    ];
    let hardcoded_iter = hardcoded.iter().map(PathBuf::from);

    // Create an iterator over the files in the specs/ directory that have a .txt extension
    let mut spec_files = fs::read_dir("./specs")
        .expect("Could not find the 'specs' directory")
        .filter_map(Result::ok)
        .map(|d| d.path())
        .filter(|p| p.extension().map(|e| e.to_owned()).is_some())
        .chain(hardcoded_iter)
        .collect::<Vec<_>>();
    // Sort by spec names
    spec_files.sort_by(|p, q| p.file_stem().cmp(&q.file_stem()));
    let spec_files = spec_files;

    for file_path in &spec_files {
        let mut raw_spec = String::new();

        File::open(file_path)
            .and_then(|mut f| f.read_to_string(&mut raw_spec))
            .expect("Could not read the spec file");

        let rs_test_file = PathBuf::from("./tests/suite/")
            .join(file_path.file_name().expect("Invalid filename"))
            .with_extension("rs");

        let mut spec_rs =
            File::create(&rs_test_file).expect(&format!("Could not create {:?}", rs_test_file));

        let spec_name = file_path.file_stem().unwrap().to_str().unwrap();

        let spec = Spec::new(&raw_spec);
        let mut n_tests = 0;

        spec_rs
            .write_all(b"// This file is auto-generated by the build script\n")
            .unwrap();
        spec_rs
            .write_all(b"// Please, do not modify it manually\n")
            .unwrap();
        spec_rs
            .write_all(b"\nuse super::{default_test_opts, test_markdown_html};\n")
            .unwrap();
        spec_rs
            .write_all(b"use pulldown_cmark::Options;\n")
            .unwrap();

        for (i, testcase) in spec.enumerate() {
            spec_rs
                .write_fmt(format_args!(
                    r###"
#[test]
fn {}_test_{i}() {{
    let original = r##"{original}"##;
    let expected = r##"{expected}"##;

    {opts}
    test_markdown_html(original, expected, opts);
}}
"###,
                    spec_name,
                    i = i + 1,
                    original = testcase.original,
                    expected = testcase.expected,
                    opts = testcase.test_opts.gen_opts()
                ))
                .unwrap();

            n_tests += 1;
        }

        println!(
            "cargo:warning=Generated {} tests in {:?}",
            n_tests, rs_test_file
        );
    }

    // write mods to suite/mod.rs
    let suite_mod_file = PathBuf::from("./tests/suite/mod").with_extension("rs");

    let mut mod_rs =
        File::create(&suite_mod_file).expect(&format!("Could not create {:?}", &suite_mod_file));

    mod_rs
        .write_all(b"// This file is auto-generated by the build script\n")
        .unwrap();
    mod_rs
        .write_all(b"// Please, do not modify it manually\n")
        .unwrap();
    mod_rs
        .write_all(b"\npub use super::{default_test_opts, test_markdown_html};\n\n")
        .unwrap();

    for file_path in &spec_files {
        let mod_name = file_path.file_stem().unwrap().to_str().unwrap();
        mod_rs.write_all(b"mod ").unwrap();
        mod_rs.write_all(mod_name.as_bytes()).unwrap();
        mod_rs.write_all(b";\n").unwrap();
    }
}

#[cfg(feature = "gen-tests")]
pub struct Spec<'a> {
    spec: &'a str,
}

#[cfg(feature = "gen-tests")]
impl<'a> Spec<'a> {
    pub fn new(spec: &'a str) -> Self {
        Spec { spec }
    }
}

#[cfg(feature = "gen-tests")]
pub struct TestCase {
    pub original: String,
    pub expected: String,
    pub test_opts: TestCaseOptions,
}

#[cfg(feature = "gen-tests")]
#[derive(Default)]
pub struct TestCaseOptions {
    pub smart_punct: bool,
    pub metadata_blocks: bool,
    pub old_footnotes: bool,
    pub subscript: bool,
    pub wikilinks: bool,
    pub deflists: bool,
    pub container_extensions: bool,
}

#[cfg(feature = "gen-tests")]
impl<'a> Iterator for Spec<'a> {
    type Item = TestCase;

    fn next(&mut self) -> Option<TestCase> {
        let spec = self.spec;
        let prefix = "```````````````````````````````` example";

        let (i_start, test_opts) = self.spec.find(prefix).and_then(|pos| {
            let smartpunct_suffix = "_smartpunct\n";
            let metadata_blocks_suffix = "_metadata_blocks\n";
            let old_footnotes_suffix = "_old_footnotes\n";
            let super_sub_suffix = "_super_sub\n";
            let wikilinks_suffix = "_wikilinks\n";
            let deflists_suffix = "_deflists\n";
            let container_extensions_suffix = "_container_extensions\n";

            let mut test_opts = TestCaseOptions::default();

            if spec[(pos + prefix.len())..].starts_with(smartpunct_suffix) {
                test_opts.smart_punct = true;
                Some((pos + prefix.len() + smartpunct_suffix.len(), test_opts))
            } else if spec[(pos + prefix.len())..].starts_with(metadata_blocks_suffix) {
                test_opts.metadata_blocks = true;
                Some((pos + prefix.len() + metadata_blocks_suffix.len(), test_opts))
            } else if spec[(pos + prefix.len())..].starts_with(old_footnotes_suffix) {
                test_opts.old_footnotes = true;
                Some((pos + prefix.len() + old_footnotes_suffix.len(), test_opts))
            } else if spec[(pos + prefix.len())..].starts_with(super_sub_suffix) {
                test_opts.subscript = true;
                Some((pos + prefix.len() + super_sub_suffix.len(), test_opts))
            } else if spec[(pos + prefix.len())..].starts_with(wikilinks_suffix) {
                test_opts.wikilinks = true;
                Some((pos + prefix.len() + wikilinks_suffix.len(), test_opts))
            } else if spec[(pos + prefix.len())..].starts_with(deflists_suffix) {
                test_opts.deflists = true;
                Some((pos + prefix.len() + deflists_suffix.len(), test_opts))
            } else if spec[(pos + prefix.len())..].starts_with(container_extensions_suffix) {
                test_opts.container_extensions = true;
                Some((
                    pos + prefix.len() + container_extensions_suffix.len(),
                    test_opts,
                ))
            } else if spec[(pos + prefix.len())..].starts_with('\n') {
                Some((pos + prefix.len() + 1, test_opts))
            } else {
                None
            }
        })?;

        let i_end = self.spec[i_start..]
            .find("\n.\n")
            .map(|pos| (pos + 1) + i_start)?;

        let e_end = self.spec[i_end + 2..]
            .find("````````````````````````````````\n")
            .map(|pos| pos + i_end + 2)?;

        self.spec = &self.spec[e_end + 33..];

        let test_case = TestCase {
            original: spec[i_start..i_end].to_string().replace("→", "\t"),
            expected: spec[i_end + 2..e_end].to_string().replace("→", "\t"),
            test_opts,
        };

        Some(test_case)
    }
}

#[cfg(feature = "gen-tests")]
impl TestCaseOptions {
    fn gen_opts(&self) -> String {
        let mut s = String::new();

        s.push_str("let mut opts = default_test_opts();");

        if self.wikilinks {
            s.push_str("\n    opts.insert(Options::ENABLE_WIKILINKS);");
        }
        if self.subscript {
            s.push_str("\n    opts.insert(Options::ENABLE_SUBSCRIPT);");
        }
        if self.old_footnotes {
            s.push_str("\n    opts.insert(Options::ENABLE_OLD_FOOTNOTES);");
        } else {
            s.push_str("\n    opts.insert(Options::ENABLE_FOOTNOTES);");
        }
        if self.metadata_blocks {
            s.push_str("\n    opts.insert(Options::ENABLE_YAML_STYLE_METADATA_BLOCKS);");
            s.push_str("\n    opts.insert(Options::ENABLE_PLUSES_DELIMITED_METADATA_BLOCKS);");
        }
        if self.smart_punct {
            s.push_str("\n    opts.insert(Options::ENABLE_SMART_PUNCTUATION);");
        }
        if self.deflists {
            s.push_str("\n    opts.insert(Options::ENABLE_DEFINITION_LIST);");
        }
        if self.container_extensions {
            s.push_str("\n    opts.insert(Options::ENABLE_CONTAINER_EXTENSIONS);");
        }

        s
    }
}
